# 5.2.3封装、继承和多态进阶（三）

### 任务描述

本关任务：通过一个简单实例讲解并自己动手编写一个Java应用程序，全面复习Java面向对象知识。

#### 相关知识

为了完成本关任务，我们通过一个实例来一步一步总结归纳Java面向对象的知识。

```
package test;/*知识点目录1，Java继承1.1 继承的概念1.2 继承的特性1.3 继承关键字1.4 构造器2，Java重写（Override）与重载（Overload）2.1 重写（Override）2.2 重载（Overload）2.3 总结3，Java多态3.1 多态的实现方式4，Java抽象类5，Java封装6，Java接口*//* 1.1继承的概念继承在本职上是特殊——一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。通过 extends 关键字可以声明一个类是从另外一个类继承而来的。*//* 1.2继承的特性1).子类拥有父类非private的属性，方法；2).子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；3).子类可以用自己的方式实现父类的方法；4).Java的继承是单继承，这是Java继承区别于C++继承的一个特性；5).提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。*//* 1.3继承关键字1).使用 extends 和 implements 来实现继承，所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承Object；2).一个子类只能拥有一个父类，所以 extends 只能继承一个类；3).使用 implements 关键字变相的使Java具有多继承的特性，为类继承接口，可以同时继承多个接口；4).通过super关键字来实现对父类成员的访问，用来引用当前对象的父类；5).final 关键字5.1) 声明类则把类定义为不能继承的，即最终类；修饰方法，则该方法不能被子类重写；定义实例变量，则变量不能被修改；5.2) final 类的方法自动为 final方法，但实例变量不自动是 final变量。*/interface A{}interface B{}class Animal{   public void move(){       System.out.println("动物可以移动");   }   Animal(){       System.out.println("Animal()");   }   Animal(int n){       System.out.println("Animal(int)");   }}final class Dog extends Animal implements A,B {   final String name = "旺财";   final public void finalFun(){   }   /* 2.1.1 重写（Override）    1).重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写；    2).重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法；    3).重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。    */   public void move(){       System.out.println("狗可以跳墙");   }   /*2.2.1重载(Overload)   1).重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同；   2).每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。    */   public void move(int n){       System.out.println("这只狗可以跳"+n+"米的墙");   }   public String toString() {       //1.3.1 通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。       return "I am a Dog " + super.toString();   }/* 1.4 构造器1).子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表；2).如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。*/   Dog(){       super(300);       System.out.println("Dog()");   }   Dog(int n){       System.out.println("Dog(int)");   }}class Test{   static void testsuper(){       System.out.println("-----testsuper----");       new Dog();       new Dog(1);   }   static void testoverride(){       System.out.println("-----testoverride-----");       Animal a = new Animal();       Animal b = new Dog();       a.move();       /*2.1.2  重写（Override）       1).尽管b属于Animal类型，但是它运行的是Dog类的move方法；       2).在编译阶段，只是检查参数的引用类型。在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。        */       b.move();   }}public class JavaDemo{   public static void main(String[] args) {       Test.testsuper();       Test.testoverride();   }}/* 2.1.3方法的重写规则1).参数列表必须完全与被重写方法的相同；2).返回类型必须完全与被重写方法的返回类型相同；3).访问权限不能比父类中被重写的方法的访问权限更低；4).父类的成员方法只能被它的子类重写；5).声明为final的方法不能被重写；6).声明为static的方法不能被重写，但是能够被再次声明；7).子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法；8).子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法；9).重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常，但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以；10).构造方法不能被重写；11).如果不能继承一个方法，则不能重写这个方法。*//*2.2.2重载规则1).被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；2).被重载的方法可以改变返回类型；3).被重载的方法可以改变访问修饰符；4).被重载的方法可以声明新的或更广的检查异常；5).方法能够在同一个类中或者在一个子类中被重载；6).无法以返回值类型作为重载函数的区分标准。*//*重写与重载之间的区别区别点            重载方法        重写方法参数列表       必须修改        一定不能修改返回类型       可以修改        一定不能修改异常                可以修改        可以减少或删除，一定不能抛出新的或者更广的异常访问                可以修改        一定不能做更严格的限制（可以降低限制）总结方法的重写和重载是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。*//*访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。默认的，也称为 default，在同一包内可见，不使用任何修饰符；私有的，以 private 修饰符指定，在同一类内可见；共有的，以 public 修饰符指定，对所有类可见；受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。我们可以可以通过以下表来说明访问权限：访问控制修饰符      当前类      同一包内     子孙类      其他包public             Y                   Y                  Y                   Yprotected      Y                   Y                  Y                  Ndefault           Y                   Y                  N                 Nprivate            Y                  N                  N                 N*//*3，Java多态多态就是同一个接口，使用不同的实例执行不同操作。3.1 多态的实现方式 重写、接口、抽象类和抽象方法。*//*4，Java抽象类1).使用abstract class来定义抽象类，抽象类不能被实例化；2).抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；3).抽象类中的抽象方法只是声明，不包含方法体；4).构造方法，类方法（用static修饰的方法）不能声明为抽象方法；5).任何子类必须重写父类的抽象方法，或者声明自身为抽象类。*/abstract class Employee{   //抽象方法   public abstract double computePay();}/*4.2继承抽象类*/class Salary extends Employee{   public double computePay(){        return 0;      }}/*5，Java封装封装（英语：Encapsulation）是指，一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装的优点：1).良好的封装能够减少耦合；2).类内部的结构可以自由修改；3). 可以对成员变量进行更精确的控制；4). 隐藏信息，实现细节。实现Java封装的步骤：1). 修改属性的可见性来限制对属性的访问；2).对每个值属性提供对外的公共方法访问。*//*6，Java接口1).接口，在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明；2).一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；3).接口不能包含成员变量，除了 static 和 final 变量；4).接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract；5).接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量；6).接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；7).类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；8).类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；9).接口的继承使用extends关键字,允许多重继承,可能定义或继承相同的方法。*/interface C extends A,B{}
```

输出结果： `-----testsuper----` `Animal(int)` `Dog()` `Animal()` `Dog(int)` `-----testoverride-----` `Animal()` `Animal(int)` `Dog()` `动物可以移动` `狗可以跳墙`

#### 编程要求

教练和运动员案例：

- 乒乓球运动员和篮球运动员；
- 乒乓球教练和篮球教练；
- 跟乒乓球相关的人员都需要学习英语；
- 分析，这个案例中有哪些抽象类，哪些接口，哪些具体类。

分析过程如下：

![img](https://data.educoder.net/api/attachments/UnRlRDJvZHJmTmtlaVdNY1dnN1hGZz09)

\- 具体输出要求请看测试说明。

#### 测试说明

测试输入： `张继科` `30` `易建联` `31` `刘国梁` `42` `杜锋` `37` 预期输出： `张继科---30` `人都是要睡觉的` `乒乓球运动员吃大白菜，喝小米粥` `乒乓球运动员学习如何发球和接球` `乒乓球运动员说英语` `----------------` `易建联---31` `人都是要睡觉的` `篮球运动员吃牛肉，喝牛奶` `篮球运动员学习如何运球和投篮` `----------------` `刘国梁---42` `人都是要睡觉的` `乒乓球教练吃小白菜，喝大米粥` `乒乓球教练教如何发球和接球` `乒乓球教练说英语` `----------------` `杜锋---37` `人都是要睡觉的` `篮球教练吃羊肉，喝羊奶` `篮球教练教如何运球和投篮` `----------------`

------

开始你的任务吧，祝你成功！