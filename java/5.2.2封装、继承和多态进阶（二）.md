# 5.2.2封装、继承和多态进阶（二）

### 任务描述

本关任务：按要求编写一个`Java`应用程序，巩固`Java`封装、继承和多态的知识。

#### 相关知识

为了完成本关任务，你需要掌握：1.重写和重载；2.`abstract`(抽象类)和`interface`(接口)；3.`final`关键字；4.`static`关键字；5.多态。

##### 重写和重载

方法重载（`overload`）：

- 必须是同一个类；
- 方法名（也可以叫函数）一样；
- 参数类型不一样或参数数量或顺序不一样；
- 不能通过返回值来判断重载。

方法的重写（`override`）子类重写了父类的同名方法，两同两小一大原则：

- 方法名相同，参数类型相同；
- 子类返回类型是父类返回类型的子类；
- 子类抛出异常小于等于父类方法抛出异常；
- 子类访问权限大于等于父类方法访问权限。

![img](https://data.educoder.net/api/attachments/YlE3Myt5NFV4bkJjbU1XYVlQNzdmdz09)

- 在重写中，运用的是动态单分配，根据`new`的类型确定对象，从而确定调用的方法；

- 在重载中，运用的是静态多分配，根据静态类型确定对象，不能根据`new`的类型确定调用方法；

- 多态中，`Father f = new Son()`。

    成员变量：编译运行参考左边；  成员函数：编译看左边，运行看右边；  静态函数：编译运行看左边。

##### `abstract`(抽象类)和`interface`(接口)

抽象类

- 用`abstract`修饰的类表示**抽象类**，抽象类位于继承树的抽象层，抽象类不能被实例化。
- 用`abstract`修饰的方法表示**抽象方法**，抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现，把具体实现留给继承该类的子类。

抽象类特点：

- 含有抽象方法的类必须声明为抽象类（不管其中是否有其他方法）；
- 抽象类可以没有抽象方法，可以有普通方法；
- 抽象类必须被继承，抽象方法必须被重写（若子类还是抽象类，不需要重写）；
- 抽象类不能被实例化（不能直接构造一个该类的对象）。

抽象方法特点：

- 在类中没有方法体（抽象方法只需声明，而不需实现某些功能）；
- 抽象类中的抽象方法必须被实现；
- 如果一个子类没有实现父类中的抽象方法，则子类也变成了一个抽象类。

接口 `interface` 中的方法默认为**`public`** `abstract `（`public`、`abstract`可以省略），变量默认为`public static final`；类中的方法全部都是抽象方法。只有声明没有实现，在不同类中有不同的方法实现。

不同点：

- 接口中只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类中可以包含普通方法；
- 接口里不能定义静态方法（`jdk1.8`下可以定义`static`方法），抽象类可以定义静态方法；
- 接口中只能定义静态常量，不能定义普通成员变量；抽象类即可以定义变量又可以定义静态常量；
- 接口中不包含构造器，抽象类里可以包含构造器，抽象类中的构造器并不是用于创建对象，而是让其他子类调用这些构造器来完成抽象类的初始化操作；
- 接口里不能包含初始化块，但抽象类可以包含；
- 一个类最多只能有一个父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。

共同点：

- 接口和抽象类都不能被实例化，都位于继承树的顶端，用于被其他类实现的继承；
- 接口和抽象类都可以包含抽象方法，实现接口和继承抽象类的普通子类都必须实现这些方法。

![img](https://data.educoder.net/api/attachments/ak9vVnJnZFNkajFpbnU1cnFJcHVydz09)

##### `final`关键字

- `final`修饰的**类**，就是最终类，不能被继承。
- `final`修饰的**方法**，就是最终方法，最终方法不能被**重写**。
- `final`修饰一个**引用变量**时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。修饰**基本数据类型**变量时，内容不能变。
- **`final`成员变量必须在初始化代码块或在构造器中初始化。**

作用：

- `final`类：如果一个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会再被扩展，那么就设计成`final`类。
- `final`方法：①把方法锁定，防止任何继承类修改它的意义和实现。②高效，编译器在遇到调用`final`方法时候会转入内嵌机制，大大提升执行效率。

##### `static`关键字

- `static`修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效。**`static`不能修饰局部变量。`static`方法内部不能调用非静态方法。**
- 静态变量只能在类主体中定义，不能在方法中定义；
- `static`变量只会创建一份，不管创建几个对象，都共用一个变量。

**类方法**指被`static`修饰的方法，无`this`指针。其他的就是**实例方法。**类方法可以调用其他类的`static`方法。 类方法和对象方法的区别：

1、 类方法是属于整个类的，而实例方法是属于类的某个对象的。 由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：

- 类方法中不能引用对象变量；
- 类方法中不能调用类的对象方法；
- 在类方法中不能使用`super`、`this`关键字。（**`this`表示当前类的对象，由`static`修饰的方法是类直接调用，不需要创建对象，所以不能用`this`**）；
- 类方法不能被覆盖。

2、与类方法相比，对象方法几乎没有什么限制：

-  对象方法中可以引用对象变量，也可以引用类变量；
- 对象方法中可以调用类方法；
- 对象方法中可以使用`super`、`this`关键字。

`static`关键字的作用

- 为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关；实现某个方法或属性与类而不是对象关联在一起；
- 静态变量属于类，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间。

##### 多态

- 定义：不同类的对象对同一消息做出响应。同一消息可以根据发送对象的不同而采用多种不同的行为方式；
- 多态存在的三个必要条件：**继承、重写、父类引用指向子类对象**；
- Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载；
- 父类引用指向子类对象，该引用不能再访问子类新增的成员。`Animal cat = new Cat()`与直接`new`一个父类实例(`Animal a = new Animal()`)的区别？ 答：当父类是接口和抽象类时，不能实例化，只能运用多态，向上转型。普通类中，可以在子类中重写父类中的方法，这样就可以访问子类中的重写方法。

#### 编程要求

按照要求编写一个`Java`应用程序：

- 定义一个抽象类`Person`，包含抽象方法`eat()`，封装属性`name`、`sex`、`age`，声明包含三个参数的构造方法；
- 定义一个`Chinese`类，继承自`Person`类，重写父类的`eat()`方法，并定义一个自己特有的方法`shadowBoxing()`；
- 定义一个`English`类，继承自`Person`类，重写父类的`eat()`方法，并定义一个自己特有的方法`horseRiding()`；
- 编写测试类，定义一个`showEat()`方法，使用父类作为方法的形参，实现多态，分别调用`showEat()`方法，通过强制类型转换调用各自类特有的方法；
- 具体输出要求请看测试说明。

#### 测试说明

测试输入： `张三` `男` `20` `史蒂文` `男` `22` 预期输出： `姓名：张三，性别：男，年龄：20，我是中国人，我喜欢吃饭!` `姓名：史蒂文，性别：男，年龄：22，我是英国人，我喜欢吃三明治!` `张三在练习太极拳!` `史蒂文在练习骑马！`

------

开始你的任务吧，祝你成功！